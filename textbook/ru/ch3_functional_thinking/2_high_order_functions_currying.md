Функции высшего порядка / Каррирование / Замыкания
==================================================

## Введение
Как вы могли заметить ранее, существует два способа
[указания типа][types-fun-vals] функций в `Scala`:

 - объектно-ориентрованный: `f: Function2[Int, String, String]`
 - функциональный: `f: (Int, String) => String`

Использование конкретного типа зависит от ситуации. Однако, что в первом, что во
втором случае, тип функции сложно читать. Рекомендуется связывать тип наиболее
часто используемой функции с некоторым псевдонимом, например:

    type Action = () => Unit

Выше продемонстрирована функция которая не принимает и не возвращает аргументов.
В случае, если у вас используются Generic-параметры, вполне допустимо
использовать для `Function1` функциональный стиль прямо на месте:

    def map[B](f: A => B) = ...

Указание типа функций, для функциональных языков, имеет смысл, так как в этих
языках существует возможность принимать и передавать функции, в качестве
аргументов. Но обо всем по порядку.

## О хороших функцияx и композиции
В лямбда-исчислении, функция должна принимать один аргумент и возвращать один
аргумент. Собственно, функция должна иметь [арность][arity] 1. Поэтому в
некоторых функциональных языках отсутствуют функции, `теоретически` принимающие
более одного аргумента. Однако пользователи этого не замечают. Далее мы будем
рассказывать о функциях с арностью 1, в виду наличия у них особых свойств.

Композиция функций ([function composition][fun-comp]) это простейший и основной
способ комбинирования функций, основанный размещении функций таким образом, что
выход одной функции, является входом для другой. Давайте рассмотрим две простые
функции:

    def inc (x: Int) = x + 1
    def dup (x: Int) = x * 2

Задача перед нами стоит следующая, собрать функцию, которая принимает целое
число, добавляет к нему единицу, а затем удваивает.

    def incDup(x: Int) = dup(inc(x))

Собственно, выше только что была продемонстрирована композиция функций. Во
многих функциональных языках, например в `Haskell` существует поддержка особого
синтаксиса для композиции функций:

    -- Код на haskell. Объявление функций.
    Prelude> let inc x = x + 1
    Prelude> let dup x = x * 2

    -- новая функция которая является результатом композиции
    -- передача и просовывание x подразумеваются синтаксисом :)
    Prelude> let incDup = dup . inc

    -- проверяем результат
    Prelude> incDup 3
    8

Давайте посмотрим на то, как это сделано в `SML`:

    (* Объявили наши функции *)
    - fun inc(x: int) = x + 1;
    val inc = fn : int -> int

    - fun dup(x: int) = x * 2;
    val dup = fn : int -> int

    (* Подразумевается наличие неявного аргумента *)
    - val incDup = dup o inc;
    val incDup = fn : int -> int

    (* Проверим результат *)
    - incDup 3;
    val it = 8 : int

`Scala` не является исключением, в ней тоже есть аналогичная операция, которая,
кстати применима только к типу `Function1`. Итак, перепишем функцию `incDup`
аналогичным образом:

    // Теперь Scala
    val incDup = dup _ compose inc _

    // Достаточно информативно :)
    incDup: Int => Int = scala.Function1$$Lambda$1098/1854577712@5d01ea21

    // Проверяем результат
    scala> incDup(3)
    res0: Int = 8

Скорее всего, вы уже заметили что данные конструкции следует читать
справа-налево. Не всем привычно, не всем удобно. Метод `andThen` позволяет
задавать порядок применения функций слева-направо:

    scala> val incDup2 = inc _ andThen dup _
    incDup2: Int => Int = scala.Function1$$Lambda$1112/312470853@23592946

    // Проверяем еще раз
    scala> incDup2(3)
    res4: Int = 8


## Анонимные функции (лямбда выражения)
[Читать][lambda-0] про [анонимные][lambda-1] функции (они же лямбды).
Данные конструкции есть во всех современных языках, поэтому мы предполагаем
что у вас наличествует представление о них. Про `Underscore syntax` (синтаксис с
нижним подчеркиванием) вы можете прочитать [здесь][underscore-syntax].


## Функции высшего порядка (High order functions)
Функцией [высшего порядка][high-order-0] может называться хотя бы одна из
перечисленных ниже функций:

 - Функция, которая принимает другую функцию в качестве параметра
 - Функция, которая возвращает другую функцию

Давайте подробнее рассмотрим первый случай. Представьте, что нам написать
небольшое приложение которое чертит на экране график заданной функции. В первом
приближении это может выглядеть так:

    type Point = (Double, Double)

    sealed trait Funname
    case object Sinus extends Funname
    case boject Cosinus extends Funname

    val xs = -10.0 to 10.0 by 0.1

    // Предположим у нас уже есть некая функция которая чертит график
    // по заданным точкам
    def plot(points: Seq[Point]) = ???

    def plotFunction(name: Funname) = name match {
      case Sinus =>
        // получаем список вычисленных значений
        val ys = (xs map math.sin)
        // склеиваем значение абсциссы и ординаты
        val coords = xs zip ys
        plot(coords)
      case Cosinus =>
        // аналогично
    }

Иметь некое подобие `switch` не самая лучшая идея. Слишком много дублирующего
кода. Вот, если бы можно было передать саму функцию...

Для начала, конечно оговорим, что функция `plot` будет способна чертить только
функцию для одного аргумента.

    type Plotfun = Double => Double

    // Вот и все.
    def plotFunction(fun: Plotfun): Unit = {
      val ys = xs map fun
      val coords = xs zip ys
      plot(coords)
    }

    // Давайте сделаем заглушку для функции plot
    def plot(coords: Seq[Point]) =
      coords.take(5) foreach println

    // И проверим наши результаты
    scala> plotFunction(math.sin)
    (-10.0,0.5440211108893698)
    (-9.5,0.0751511204618093)
    (-9.0,-0.4121184852417566)
    (-8.5,-0.7984871126234903)
    (-8.0,-0.9893582466233818)

    scala> plotFunction(math.cos)
    (-10.0,-0.8390715290764524)
    (-9.5,-0.9971721561963784)
    (-9.0,-0.9111302618846769)
    (-8.5,-0.6020119026848236)
    (-8.0,-0.14550003380861354)

Как видите функции `math.cos`, а также `math.sin` замечательно себя
зарекомендовали. Написанный код будет работать для любой функции типа
`Double => Double`.

Когда нужно возвращать другую функцию?
Наиболее распространенным случаем является каррирование, про него будет
рассказано ниже. Достаточно понятный пример вы можете найти
[здесь][high-order-2]. Также про функции высшего порядка можно прочесть еще и
[здесь][high-order-1].


## Каррирование (Currying)
[Техника][curry-0], которая позволяет рассматривать функцию с несколькими
аргументами, в цепочку функций принимающих один аргумент. В некоторых
функциональных языках, таких как `Haskell` все функции каррируются по умолчанию
(и ничего страшного не происходит). Каррирование -- это достаточно сложная тема,
на понимание которой у объектно-ориентированного уходит много времени. На самом
деле все просто.

Усвоение этой техники необходимо. Использовать ее не обязательно, однако
большинство библиотек использует каррирование. И чтобы понимать их код, вам
придется эту технику освоить.

> Проще говоря, каррирование представляет собой процесс разбиения одной функции
> с несколькими аргументами на цепочку функций с одном аргументом, которые
> возвращают функцию с n-1 аргументами, которая возвращать функцию с n-2
> аргументами, пока дело не дойдет до последнего, единственного аргумента

Перед тем как вы глубоко погрузитесь в каррирование, мы бе хотели чтобы вы
познакомились с альтернативным способом указания типов функций в `Scala` и
других функциональных языках:

    // Тип этой функции String => String
    // функция из одного строкового аргумента, возвращающя строку
    def sayMyName(name: String): String = "Your name: name"

    // Тип этой функции (String, String) => String
    def concat(first: String, second: String) = first + second

Любую функцию принимающую более одного элемента, можно представить как цепочку
функций, принимающих один аргумент.

    // Перепишем эту же функцию используя нотацию для каррирования
    // Тип этой функции String => String => String
    def concat(first: String)(second: String) = first + second

    // Давайте проверим как она работает
    сoncat("Hello")(" world")
    // res1: String = Hello world

Каррирование, в первую очередь, необходимо для повторного использования кода:

    // говорит "Привет" каждому пользователю вошедшему в систему:
    def sayHello(name: String): String = ???

И конечно же, мы можем реализовать эту функцию так:

    def sayHello(name: String) = "Hello " + name

А можем повторно использовать общую функцию `concat`:

    val greet = concat("Hello ")_
    // greet: String => String = $$Lambda$1170/364266169@518bfd90

И что мы получили? Вместо функции `(String, String) => String` мы получили
функцию `String => String`

    greet("Robert")
    // res8: String = Hello Robert

Из всех статей, посвященный каррированию, мы рекомендуем [эту][curry-1].
Достаточно неплохо, карирование описано [здесь][curry-2], [здесь][curry-3] и
[здесь][curry-5]. Про то как каррирование работает в байткоде написано
[здесь][curry-4].


## Замыкания (Closures)
Про замыкания хорошо написано [здесь][closures-0] и [здесь][closures-1].
[Статья][closures-2], которая может показаться вам достаточно понятной.


Литература
==========
 - Узнать больше про композицию функций вы можете на сайте
   [Twitter Scala School][ss-pm]


[types-fun-vals]: http://docs.scala-lang.org/style/types.html#function-values
[arity]: https://en.wikipedia.org/wiki/Arity
[ss-pm]: http://twitter.github.io/scala_school/pattern-matching-and-functional-composition.html#composition
[fun-comp]: https://en.wikipedia.org/wiki/Function_composition_(computer_science)
[underscore-syntax]: http://stackoverflow.com/a/7678951/1655785

[curry-0]: https://en.wikipedia.org/wiki/Currying
[curry-1]: http://lukajcb.github.io/blog/scala/2016/03/08/a-real-world-currying-example.html
[curry-2]: https://en.wikibooks.org/wiki/Scala/Currying
[curry-3]: http://docs.scala-lang.org/tutorials/tour/currying.html
[curry-4]: http://alvinalexander.com/scala/scala-curried-partially-applied-functions-how-compiled-scalac
[curry-5]:  http://fruzenshtein.com/scala-currying-functions/

[closures-0]: http://alvinalexander.com/scala/how-to-use-closures-in-scala-fp-examples
[closures-1]: http://www.slideshare.net/knoldus/functions-closures
[closures-2]: http://openhome.cc/eGossip/Blog/UnderstandingLambdaClosure4.html

[lambda-0]: http://docs.scala-lang.org/tutorials/tour/anonymous-function-syntax.html
[lambda-1]: https://en.wikipedia.org/wiki/Anonymous_function

[high-order-0]: https://en.wikipedia.org/wiki/Higher-order_function
[high-order-1]: http://docs.scala-lang.org/tutorials/tour/higher-order-functions
[high-order-2]: http://fruzenshtein.com/scala-higher-order-anonymous-functions/

