Задания для главы 1
===================

После изучения главы вам предлагается решить три небольших
задачи. Для каждой предполагается рекурсивное решение с
использованием сопоставления с образцом (pattern-matching).

## Задача 1
Требуется подсчитать количество вхождений подстроки в заданную строку.
Для следующей функции:

    def substringCount(s: String, sub: String): Int = ???

ожидается следующий вывод:

    substringCount("catcowcat", "cat") -> 2
    substringCount("catcowcat", "c")   -> 3
    substringCount("abracadabra", "z") -> 0

Однако, для следующего случая:

    substringCount("aaaaa", "aa") -> 4


## Задача 2
Задача на балансировку скобок. Следует написать функцию, которая на
вход принимает список символов и возвращает истину, если открывающие
скобки полностью сбалансированы закрывающими.

## Задача 3
Требуется выполнить подсчет места, занимаемого директорией на диске, с
учетом всех вложенных файлов. Программа должна использовать интерфейс
командной строки. В качестве единственного аргумента она должна
принимать путь к каталогу, размер которого требуется посчитать. В
случае отсутствия параметров, должен быть выполнен подсчет размера
текущего каталога. Если файл невозможно прочитать, программа должна
продолжить работу, выведя на stdin сообщение об ошибке вместе
с именем файла.


Литература
==========
Старайтесь использовать хвостовую рекурсию там, где есть такая
возможность. В этом поможет аннотация `@tailrec`. О хвостовом вызове
вы можете прочесть [здесь][tail-call].

[пост][trampolines] и [пост][scala-rec-fun], о том как это применено в Scala.
Интересная статья на сайте [Dr. Dobbs][tcall-opt], посвященная оптимизации
хвостовой рекурсии для JVM.

[tail-call]: https://en.wikipedia.org/wiki/Tail_call
[trampolines]: http://blog.richdougherty.com/2009/04/tail-calls-tailrec-and-trampolines.html
[scala-rec-fun]: http://fruzenshtein.com/scala-recursive-function/
[tcall-opt]: http://www.drdobbs.com/jvm/tail-call-optimization-and-java/240167044

